<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deterministic Flappy Bird</title>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
        font-family: Arial, sans-serif;
      }
      #gameCanvas {
        border: 2px solid #333;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="288" height="512"></canvas>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      const FPS = 60;
      const FRAME_TIME = 1000 / FPS;
      const GRAVITY = 0.25;
      const JUMP_FORCE = -4.6;
      const PIPE_SPEED = 2;
      const PIPE_WIDTH = 52;
      const PIPE_GAP = 100;
      const BIRD_SIZE = 20;

      let birdY, birdVelocity, pipes, score, gameOver;
      let originalReplayData = [];
      let currentReplayData = [];
      let isReplaying = false;
      let seed, randomGenerator;
      let frameCount = 0;
      let accumulator = 0;
      let lastTime = 0;
      let isClicked = false;

      const buttons = [
        {
          x: 50,
          y: 300,
          width: 180,
          height: 40,
          text: "Start New Game",
          action: () => init(),
        },
        {
          x: 50,
          y: 350,
          width: 180,
          height: 40,
          text: "Replay Last Game",
          action: () => replay(),
        },
      ];

      function mulberry32(a) {
        return function () {
          var t = (a += 0x6d2b79f5);
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      function init(replay = false) {
        birdY = 256;
        birdVelocity = 0;
        pipes = [];
        score = 0;
        gameOver = false;
        frameCount = 0;
        accumulator = 0;
        lastTime = performance.now();
        isClicked = false;
        if (!replay) {
          seed = Date.now();
          originalReplayData = [];
        } else {
          currentReplayData = [...originalReplayData];
        }
        randomGenerator = mulberry32(seed);
        isReplaying = replay;
      }

      function replay() {
        if (originalReplayData.length === 0) return;
        init(true);
      }

      function drawBird() {
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(50, birdY, BIRD_SIZE / 2, 0, 2 * Math.PI);
        ctx.fill();
      }

      function drawPipes() {
        ctx.fillStyle = "#00FF00";
        pipes.forEach((pipe) => {
          ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.top);
          ctx.fillRect(
            pipe.x,
            pipe.bottom,
            PIPE_WIDTH,
            canvas.height - pipe.bottom
          );
        });
      }

      function drawBackground() {
        ctx.fillStyle = "#87CEEB";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(50, 50, 60, 20);
        ctx.fillRect(200, 80, 70, 20);
      }

      function drawScore() {
        ctx.fillStyle = "#000000";
        ctx.font = "24px Arial";
        ctx.fillText(`Score: ${score}`, 10, 30);
      }

      function drawButton(button) {
        ctx.fillStyle = "#4CAF50";
        ctx.fillRect(button.x, button.y, button.width, button.height);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(
          button.text,
          button.x + button.width / 2,
          button.y + button.height / 2
        );
        ctx.textAlign = "left";
        ctx.textBaseline = "alphabetic";
      }

      function fixedUpdate() {
        if (!gameOver) {
          if (isReplaying) {
            if (
              currentReplayData.length > 0 &&
              frameCount === currentReplayData[0]
            ) {
              birdVelocity = JUMP_FORCE;
              currentReplayData.shift();
            }
          } else if (isClicked) {
            birdVelocity = JUMP_FORCE;
            originalReplayData.push(frameCount);
            isClicked = false;
          }

          birdVelocity += GRAVITY;
          birdY += birdVelocity;

          if (birdY + BIRD_SIZE / 2 > canvas.height) {
            gameOver = true;
          }

          if (frameCount % 100 === 0) {
            let pipeY =
              randomGenerator() * (canvas.height - PIPE_GAP) + PIPE_WIDTH;
            pipes.push({
              x: canvas.width,
              top: pipeY - PIPE_WIDTH - PIPE_GAP,
              bottom: pipeY,
            });
          }

          pipes.forEach((pipe) => {
            pipe.x -= PIPE_SPEED;

            if (
              50 < pipe.x + PIPE_WIDTH &&
              50 + BIRD_SIZE > pipe.x &&
              (birdY < pipe.top || birdY + BIRD_SIZE > pipe.bottom)
            ) {
              gameOver = true;
            }

            if (pipe.x + PIPE_WIDTH === 50) {
              score++;
            }
          });

          pipes = pipes.filter((pipe) => pipe.x > -PIPE_WIDTH);
        }

        frameCount++;
      }

      function draw() {
        drawBackground();
        drawPipes();
        drawBird();
        drawScore();

        if (gameOver) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#FFFFFF";
          ctx.font = "32px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Game Over", canvas.width / 2, 200);
          ctx.font = "20px Arial";
          ctx.fillText(`Final Score: ${score}`, canvas.width / 2, 240);
          ctx.textAlign = "left";
          buttons.forEach(drawButton);
        }
      }

      function gameLoop(currentTime) {
        if (lastTime === 0) {
          lastTime = currentTime;
        }

        let deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        accumulator += deltaTime;

        while (accumulator >= FRAME_TIME) {
          fixedUpdate();
          accumulator -= FRAME_TIME;
        }

        draw();

        requestAnimationFrame(gameLoop);
      }

      canvas.addEventListener("mousedown", () => {
        if (!gameOver && !isReplaying) {
          isClicked = true;
        }
      });

      canvas.addEventListener("click", (event) => {
        if (gameOver) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          buttons.forEach((button) => {
            if (
              x >= button.x &&
              x <= button.x + button.width &&
              y >= button.y &&
              y <= button.y + button.height
            ) {
              button.action();
            }
          });
        }
      });

      init();
      requestAnimationFrame(gameLoop);
    </script>
  </body>
</html>
